package pattern

import "fmt"

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern
*/

type Transport interface { // интерфейс транспорта
	Deliver()
}

// Truck и Ship - это структуры, представляющие различные виды транспорта

type Truck struct{} // структура грузовика

func (t *Truck) Deliver() {
	fmt.Println("Доставка груза грузовиком")
}

type Ship struct{} // структура корабля

func (s *Ship) Deliver() {
	fmt.Println("Доставка груза кораблем")
}

type Logistics interface { // интерфейс логистической службы, который определяет фабричный метод CreateTransport()
	CreateTransport() Transport
}

// RoadLogistics и SeaLogistics - это структуры, представляющие различные виды логистических служб,
// которые реализуют интерфейс Logistics

type RoadLogistics struct{} // структура автомобильной логистики

func (rl *RoadLogistics) CreateTransport() Transport {
	return &Truck{}
}

type SeaLogistics struct{} // структура морской логистики

func (sl *SeaLogistics) CreateTransport() Transport {
	return &Ship{}
}

func main() {
	// создаём экземпляры логистических служб
	roadLogistics := &RoadLogistics{}
	seaLogistics := &SeaLogistics{}

	// используем созданные экземпляры служб для создания экземпляров транспорта
	truck := roadLogistics.CreateTransport()
	ship := seaLogistics.CreateTransport()

	// вызываем метод Deliver() на каждом экземпляре транспорта
	truck.Deliver()
	ship.Deliver()
}

/*
	Фабричный метод является порождающим паттерном.
	Он определяет обищй инерфейс для создания объектов в суперструктуре,
	позволяя подструктурам изменять типа создаваемых объектов.

	Применимость:
	Когда заранее неизвестны типа и зависимости объектов, с которыми должен работать код.
	Когда нужно предоставить возможность пользователям расширять части фреймворка или пакета.
	Когда нужно экономить системные ресурсы, повторно используя уже созданные объекты.

	+ избавляет структуру от привязки к конкретным структурам продуктов
	+ выделеляет код производства продуктов в одно место, упрощая поддержку кода
	+ упрощает добавление новых продуктов в программу
	+ реализует принцип открытости/закрытости
	- может привести к созданию больших параллельных иерархий структур, так как для
	каждой структуры продукта нужно создать свою подструктуру создателя.
*/
